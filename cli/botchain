#!/usr/bin/env node

require('babel-register')({
    presets: [ 'env' ]
})

const fs = require('fs')
const Web3 = require('web3');
const cfg = require('./modules/config.js')
const arg = require('./modules/argparse.js')

if (cfg.error) {
  process.exit()
}

if (!arg.rpc.includes('//')) {
  console.log('The supplied RPC URL needs to contain the protocol.\n  Example: \'http://my.ethereum.node\'')
  process.exit()
}

const rpc_host_and_port = arg.rpc + ":" + arg.port
console.log(rpc_host_and_port)
const web3 = new Web3(new Web3.providers.HttpProvider(rpc_host_and_port))
const approve_cost = 1*10**18;

const botCoinJSON                  = require('../build/contracts/BotCoin.json')
const ownableProxyJSON             = require('../build/contracts/OwnableProxy.json')
const devRegistryDelegateJSON      = require('../build/contracts/DeveloperRegistryDelegate.json')
const botRegistryDelegateJSON      = require('../build/contracts/BotProductRegistryDelegate.json')
const serviceRegistryDelegateJSON  = require('../build/contracts/BotServiceRegistryDelegate.json')
const instanceRegistryDelegateJSON = require('../build/contracts/BotInstanceRegistryDelegate.json')

// Botcoin Interface
const token                = web3.eth.contract(botCoinJSON.abi).at(cfg.botcoinAddr)

// Upgrade Interfaces -- The "Ownable Proxies"
const upgradeIface = new Map()
.set('dev', web3.eth.contract(ownableProxyJSON.abi).at(cfg.devProxyAddr))
.set('bot', web3.eth.contract(ownableProxyJSON.abi).at(cfg.botProxyAddr))
.set('service', web3.eth.contract(ownableProxyJSON.abi).at(cfg.serviceProxyAddr))
.set('instance', web3.eth.contract(ownableProxyJSON.abi).at(cfg.isntanceProxyAddr));

// Registry Contract Objects
// Used to create a new contract for deployment
const Registry = new Map()
.set('dev',      web3.eth.contract(devRegistryDelegateJSON.abi))
.set('bot',      web3.eth.contract(botRegistryDelegateJSON.abi))
.set('service',  web3.eth.contract(serviceRegistryDelegateJSON.abi))
.set('instance', web3.eth.contract(instanceRegistryDelegateJSON.abi));

// Registry Interfaces -- ABIs of the delegates pointed at the Proxy Addresses
const registries = new Map()
.set('dev', Registry.get('dev').at(cfg.devProxyAddr))
.set('bot', Registry.get('bot').at(cfg.botProxyAddr))
.set('service', Registry.get('service').at(cfg.serviceProxyAddr))
.set('instance', Registry.get('instance').at(cfg.isntanceProxyAddr));

function unlockAccount(account, password) {
  try {
    console.log('[Addr:',account,password,'] Unlocking ...')
    web3.personal.unlockAccount(account, password);
  } catch(e) {
    console.log('Unlock Error:',e);
    return;
  }
}

async function deployImplementation(type, addr, gas, password) {
  console.log('[Mgmt Addr: ',addr,' Gas: ',gas, ' Type: ',type,password,'] Setting up deployment ...');
  unlockAccount(addr, password)
  contract = Registry.get(type).new({from: addr, gas: gas, data: devRegistryDelegateJSON.bytecode});
  await checkDeployment(contract)
  console.dir(contract)
  return contract
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// We need to wait until any miner has included the transaction
// in a block to get the address of the contract
async function checkDeployment(contract) {
  while (true) {
    let receipt = web3.eth.getTransactionReceipt(contract.transactionHash);
    if (receipt && receipt.contractAddress) {
      console.log("Your contract has been deployed at http://testnet.etherscan.io/address/" + receipt.contractAddress);
      console.log("Note that it might take 30 - 90 sceonds for the block to propagate befor it's visible in etherscan.io");
      break;
    }
    console.log("Waiting a mined block to include your contract... currently in block " + web3.eth.blockNumber);
    await sleep(4000);
  }
}

async function approveDeveloper(password, address) {
  console.log('[Dev Addr: ',address,'] Approving ...')
  let idx = registries.get('dev').owns(address)
  console.log('[Dev Addr: ',address,'] Developer owns ID #',idx.toString())
  unlockAccount(cfg.mgmtAddr, password)
  console.log('[Dev Addr: ',address,'] unlocked Mgmt Addr: ',cfg.mgmtAddr)
  token.approve(cfg.devProxyAddr, approve_cost, {from: cfg.mgmtAddr})
  registries.get('dev').grantApproval(idx.toNumber(), {from: cfg.mgmtAddr})
  console.log('[Dev Addr: ',address,'] Approved')
}

async function revokeApproval(password, address) {
  console.log('[Dev Addr: ',address,'] Revoking approval ...')
  let idx = registries.get('dev').owns(address)
  console.log('[Dev Addr: ',address,'] Developer owns ID #',idx.toString())
  unlockAccount(cfg.mgmtAddr, password)
  console.log('[Dev Addr: ',address,'] unlocked Mgmt Addr: ',cfg.mgmtAddr)
  token.approve(cfg.devProxyAddr, approve_cost, {from: cfg.mgmtAddr})
  registries.get('dev').revokeApproval(idx.toNumber(), {from: cfg.mgmtAddr})
  let result = registries.get('dev').approvalStatus(idx.toNumber())
  console.log('[Dev Addr: ',address,'] Approval Status: ',result)
}

async function checkDevApprovalByIdx(idx) {
  console.log('[Dev Idx: ',idx,'] Checking approval status ...')
  let result = registries.get('dev').approvalStatus(idx)
  console.log('[Dev Idx: ',idx,'] Status: ',result)
}

async function checkDevApprovalByAddr(address) {
  console.log('[Dev Addr: ',address,'] Checking approval status ...')
  let idx = registries.get('dev').owns(address)
  let result = registries.get('dev').approvalStatus(idx)
  console.log('[Dev Addr: ',address,'] Status: ',result)
}

function ownerOfEntry(idx) {
  let addr = registries.get('dev').ownerOfEntry(idx)
  console.log('Entry: ', idx, ' Addr: ', addr)
}

function registration(args) {
  let success = false;
  switch(args['registration']) {
    case 'approve':
      success = approveDeveloper(arg.password[0], arg.address[0])
      break;
    case 'check-approval':
      console.log(arg)
      if (arg.address) checkDevApprovalByAddr(arg.address)
      if (arg.index)   checkDevApprovalByIdx(arg.index[0])
      break;
    case 'revoke-approval':
      success = revokeApproval(arg.password[0], arg.address[0])
      break;
    case 'get-owner':
      ownerOfEntry(args.index)
      break;
    case '':
      console.log('No valid registration command found.')
      break;
  }
}

async function deploy(args) {
  switch(args['deploy']) {
    case 'registry':
      deployImplementation(args.type[0], cfg.mgmtAddr, 7900000, args.password[0])
      break;
  }
}

switch(arg.subcommand_name) {
  case 'get':
    console.log('Command: '+arg.subcommand_name)
    // run get handler
    break;
  case 'update':
    console.log('Command: '+arg.subcommand_name)
    // run update handler
    break;
  case 'deploy':
    console.log('Command: '+arg.subcommand_name)
    deploy(arg)
    // run deploy handler
    break;
  case 'registration':
    console.log('Command: '+arg.subcommand_name)
    registration(arg)
    // run registration handler
    break;
}
  
